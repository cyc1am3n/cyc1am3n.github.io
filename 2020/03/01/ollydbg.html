<!DOCTYPE html>
<html lang="en">
<head>
  <!-- <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script> -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  
  <!-- Favicon code from realfavicongenerator.net -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#8b51a3">
<meta name="msapplication-TileColor" content="#563d7c">
<meta name="theme-color" content="#ffffff">

  <!--jQuery-->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

  <!-- Fonts & Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[Reversing] 3장 올리디버거 | Daeyoung Kim</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="[Reversing] 3장 올리디버거" />
<meta name="author" content="cyc1am3n" />
<meta property="og:locale" content="en_GB" />
<meta name="description" content="해당 포스팅은 강병탁 교수님의 수업과 리버스 엔지니어링 바이블을 참고해 작성했습니다." />
<meta property="og:description" content="해당 포스팅은 강병탁 교수님의 수업과 리버스 엔지니어링 바이블을 참고해 작성했습니다." />
<meta property="og:site_name" content="Daeyoung Kim" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-01T21:32:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="[Reversing] 3장 올리디버거" />
<meta name="twitter:site" content="@daeyoung__k" />
<meta name="twitter:creator" content="@cyc1am3n" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"cyc1am3n"},"dateModified":"2020-03-01T21:32:00+09:00","datePublished":"2020-03-01T21:32:00+09:00","description":"해당 포스팅은 강병탁 교수님의 수업과 리버스 엔지니어링 바이블을 참고해 작성했습니다.","headline":"[Reversing] 3장 올리디버거","mainEntityOfPage":{"@type":"WebPage","@id":"/2020/03/01/ollydbg.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/img/smile.png"},"name":"cyc1am3n"},"url":"/2020/03/01/ollydbg.html"}</script>
<!-- End Jekyll SEO tag -->

</head>
<!--jQuery-->
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<body>
  <div class="container">
    

<section id="header-nav">
  <header>
    <nav>
      <ul>
        
        <!-- others -->
        <a href="/">
          <li class="btn-nav">Home</li>
        </a>
        
        
        
          <a href="/blog">
            <li class="current btn-nav">Blog</li>
          </a>
          <a href="/tags">
            <li class="btn-nav">Tags</li>
          </a>
        
        
      </ul>
    </nav>
  </header>
</section>
<div id="post">
  <section class="post-header">
    <h1 class="title">[Reversing] 3장 올리디버거</h1>
    <p class="subtitle">Reverse Engineering Chapter 3. OllyDBG</p>
    <p class="meta">
      March 1, 2020
    </p>
  </section>
  <section class="post-content">
    <p>해당 포스팅은 강병탁 교수님의 수업과 <a href="https://wikibook.co.kr/reverse-engineering-bible/">리버스 엔지니어링 바이블</a>을 참고해 작성했습니다.</p>

<hr />

<h3 id="f-secure-level-1-문제-풀어보기">F-Secure level 1 문제 풀어보기</h3>

<p><img src="https://user-images.githubusercontent.com/11629647/75625914-e41e3c00-5c05-11ea-90c6-f35778176899.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>

<ul>
  <li>이 프로그램을 리버싱해서 시리얼 넘버를 찾아보자.</li>
</ul>

<h3 id="step-1-파일-스캐너로-스캔">Step 1. 파일 스캐너로 스캔</h3>

<ul>
  <li>파일 스캐너로 해당 파일의 패킹 여부를 확인하자.</li>
  <li>IAT(Import Address Table)이 제대로 보이면 패킹이 안되었다는 것이다.</li>
</ul>

<h3 id="step-2-api-확인">Step 2. API 확인</h3>

<ul>
  <li>IAT를 통해 어떤 API가 사용되었는지 확인하자.</li>
  <li>해당 dll 파일에서 어떤 함수를 불러 왔는지 알 수 있고, 이를 통해 대략적인 행위를 예상하자.</li>
  <li><code class="language-plaintext highlighter-rouge">MSVCR71.dll</code> 의 <code class="language-plaintext highlighter-rouge">_stricmp (IAT: 0x2230)</code> 을 확인할 수 있는데, 결정적으로 쓰이는 함수인지 의심해볼 필요가 있다.</li>
</ul>

<h3 id="step-3-파일의-이미지-베이스-확인">Step 3. 파일의 이미지 베이스 확인</h3>

<ul>
  <li>실행 파일의 이미지 베이스를 확인해 디버깅 할 번지가 어디인지 확인하자.</li>
  <li>PE의 Optional Header의 ImageBase를 보면 <code class="language-plaintext highlighter-rouge">0x69000000</code> 이라고 적혀있다. (대부분 400000 번지지만)</li>
</ul>

<h3 id="step-4-디버깅-해보기">Step 4. 디버깅 해보기</h3>

<ul>
  <li>
    <p>OllyBDG로 디버깅을 해보면 아까 찾은 이미지 베이스부터 시작하는 걸 볼 수 있다.</p>
  </li>
  <li>
    <p>프로그램에서 쓰인 string을 메모리에서 찾아서 트레이스를 하거나,</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_strcmp()</code> 가 쓰인 부분을 찾아 함수가 시작하는 부분에 BP를 걸고 실행시켜보자.</p>
  </li>
  <li>
    <p>여기에서는 네 가지 방법으로 같은 결과를 보여줄 수 있다.</p>

    <p><img src="https://user-images.githubusercontent.com/11629647/75625916-e97b8680-5c05-11ea-9d37-c4e0c80b3e5e.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>

    <h4 id="1-jmp-문-패치">1) Jmp 문 패치</h4>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">jnz</code>는 (레지스터의) zero flag(Z)가 켜져있지 않을 때 해당 주소로 점프하는 코드인데</li>
      <li><code class="language-plaintext highlighter-rouge">test eax, eax</code>에서 eax가 0일 때만 zero가 된다 (Z가 1로 바뀐다)</li>
      <li><code class="language-plaintext highlighter-rouge">_stricmp</code> 는 비교하는 문자가 같을 때 0을 리턴하므로 위와 같이 다른 문자를 입력했을 때는 Z=0이다.</li>
      <li>근데 여기서 <code class="language-plaintext highlighter-rouge">jnz</code> 를 <code class="language-plaintext highlighter-rouge">jz</code> 로 변경하면 Z가 꺼져있을 때만 점프하게 된다.</li>
      <li>이는 코드를 변경하는 방식이므로 무결성 검사가 이루어졌을 때는 사용할 수 없다.</li>
    </ul>

    <h4 id="2-플래그-패치">2) 플래그 패치</h4>

    <ul>
      <li>코드를 변경하지 말고 레지스터의 zero flag를 1로 변경시켜도 점프문을 통과할 수 있다.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/11629647/75625918-ed0f0d80-5c05-11ea-8d7f-3f785512addb.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>

    <h4 id="3-nop-패치">3) Nop 패치</h4>

    <ul>
      <li>점프문을 <code class="language-plaintext highlighter-rouge">nop</code> 명령어로 대체하여 Sorry 부분으로 점프하지 못하도록 변경한다.</li>
      <li>여기에서 주의할 점은 <code class="language-plaintext highlighter-rouge">nop</code> 는 1바이트이므로 2바이트(<code class="language-plaintext highlighter-rouge">jnz</code> 는 2바이트)를 맞춰서 두 번 넣어줘야한다.</li>
    </ul>

    <p>!<img src="https://user-images.githubusercontent.com/11629647/75625921-f4361b80-5c05-11ea-9862-3d2994d290ae.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>

    <h4 id="4-api-패치">4) API 패치</h4>

    <ul>
      <li>연결된 dll 부분으로 들어가 리턴값을 바꿔준다.</li>
      <li>즉, <code class="language-plaintext highlighter-rouge">MSVCR71.dll</code> 의 <code class="language-plaintext highlighter-rouge">_stricmp()</code> 함수의 리턴값을 무조건 0을 리턴하도록 만들어준다.</li>
      <li><code class="language-plaintext highlighter-rouge">_stricmp()</code> 의 최종 리턴 부분인 <code class="language-plaintext highlighter-rouge">RETN</code> 부분을 <code class="language-plaintext highlighter-rouge">XOR EAX, EAX</code> 로 변경하고 <code class="language-plaintext highlighter-rouge">RETN</code> 을 추가하자.</li>
      <li>그럼 값에 상관 없이 EAX 에는 0이 들어가고 0을 리턴하게 될 것이다.</li>
    </ul>

    <p><img src="https://user-images.githubusercontent.com/11629647/75625922-f7c9a280-5c05-11ea-91b3-411cea8c4d68.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>
  </li>
</ul>

<p><br /></p>

<h3 id="string-조작하기">String 조작하기</h3>

<ul>
  <li>한편 출력하려는 string을 변경할 수도 있는데, PUSH 하는 부분에서 ascii 값의 주소를 알아내고 아래와 같이 드래그를 한 뒤 Binary edit(Ctrl + E)를 선택하면</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/11629647/75625946-4414e280-5c06-11ea-84dc-fe040ec28d6c.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>

<ul>
  <li>이와 같이 출력 문자를 변경할 수 있다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/11629647/75625947-49722d00-5c06-11ea-8da3-5a8dc5b740dc.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>

<ul>
  <li>이 주제랑은 그렇게 상관있는 내용은 아닌데, 주소를 리틀 엔디안 방식으로 입력한다는 것을 주의해야한다.</li>
  <li><code class="language-plaintext highlighter-rouge">0x690030E8</code> → <code class="language-plaintext highlighter-rouge">E8300069</code> 로 표현</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/11629647/75625949-4e36e100-5c06-11ea-943c-6a52275e506a.png" alt="" class="center-50" /><br />
<span class="caption"></span></p>

<p><br /></p>

<h3 id="call-stack">Call Stack</h3>

<ul>
  <li>
    <p>리버스 엔지니어링을 위해 스택에 관해 알아야 할 지식은 다음과 같다.</p>

    <ol>
      <li>함수 호출 시 파라미터가 들어가는 방향</li>
      <li>리턴 주소</li>
      <li>지역 변수 사용</li>
    </ol>
  </li>
  <li>
    <p>함수 안에서 스택을 사용하게 되면 보통 다음과 같은 코드가 함수의 시작 부분에 생성된다.(fastcall)</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">push ebp      -&gt; 1. ebp 레지스터를 스택에 넣는다.
mov ebp, esp  -&gt; 2. 현재 esp의 값을 ebp에 넣는다.
sub esp, 0C   -&gt; 3. esp에서 0C만큼 뺀다.
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>여기서 <strong>esp</strong>는 현재 스택의 가장 <strong>위</strong>에 있는 데이터를 가리키고 있는 포인터이고</p>
  </li>
  <li>
    <p><strong>ebp</strong>는 현재 스택의 가장 <strong>바닥</strong>을 가리키는 포인터이다.</p>
  </li>
  <li>
    <p>두 번째 줄까지 실행시키면 ebp와 esp 값이 같아지면서 이 함수에서 지역변수는 ebp 에서부터 얼마든지 계산할 수 있다.</p>

    <ul>
      <li>ebp를 기준으로 오프셋을 더하고 빼는 작업으로 스택을 처리할 수 있게 된다는 뜻이다.</li>
    </ul>
  </li>
  <li>
    <p>스택은 LIFO 특성으로 아래로 자라는데, 특정 값만큼 빼면 그만큼 스택을 사용하겠다는 의미이다.</p>

    <ul>
      <li>따라서 세 번째 줄을 실행시키면 스택을 0C만큼 지역변수를 사용하겠다고 해석할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p>그러면 ebp는 현재 함수에서 스택의 맨 위가 되었고, 첫 번째 번지가 되었다.</p>
  </li>
  <li>
    <p>또한 사이즈를 빼가면서 자리를 확보하고 있으므로, 결국 지역 변수는 “-“ 마이너스 형태로 계산이 가능하다.</p>

    <ul>
      <li>4바이트 단위로 움직이는 변수라고 생각했을 때 ebp-4는 첫 번째 지역 변수가 될 것이고, ebp-8은 두 번째 지역 변수가 될 것이다.</li>
    </ul>
  </li>
  <li>
    <p>예제로 다시 한 번 살펴보자.</p>
  </li>
  <li>
    <p>여기서 ebp: 0019FF28 / esp: 0019FF14이다.</p>
  </li>
</ul>

<p><img src="https://user-images.githubusercontent.com/11629647/75625950-50993b00-5c06-11ea-81ae-0201934c068c.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>

<ul>
  <li>첫 번째 줄인 push ebp를 실행시키면 이전 스택의 base를 스택에 올린다.</li>
  <li>두 번째 줄인 mov ebp, esp를 실행시키면 현재 스택의 꼭대기 주소를 새로운 스택의 base를 설정한다.(새로운 스택이 시작됨)</li>
  <li>여기서 ebp: 0019FF10 / esp: 0019FF10이다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/11629647/75625952-568f1c00-5c06-11ea-92ff-deabf9781daa.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>

<ul>
  <li>세 번째 줄인 sub esp, 0C를 실행시키면 스택을 12 바이트 내려서 지역변수로 그 만큼 사용할 수 있게 된다.</li>
  <li>여기서 ebp: 0019FF10 / esp: 0019FF04이다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/11629647/75625953-5abb3980-5c06-11ea-8e34-d49dc4b3455a.png" alt="" class="center-95" /><br />
<span class="caption"></span></p>

<ul>
  <li>함수의 마지막 부분에는 스택을 원상복구 시 마지막에 있는 ebp를 pop 시켜주고 ebp+4로 리턴하면 된다.</li>
  <li>또한 전역 변수는 ebp+8부터 사용할 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="함수의-호출-규약">함수의 호출 규약</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>여기의 sum 함수를 어셈블리로 나타내면 다음과 같다.(호출 규약에 따라 변경 될 수도, 이건 cdecl)</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">⭐️</span> push ebp
<span class="err">⭐️</span> mov ebp, esp
<span class="p">push ecx
mov eax, [ebp+arg_0]
add eax, [ebp+arg_4]
mov [ebp+var_4], eax
mov eax, [ebp+var_4]
</span><span class="err">⭐️</span> mov esp, ebp
<span class="err">⭐️</span> pop ebp
<span class="err">⭐️</span> retn
</code></pre></div>    </div>
  </li>
  <li>
    <p>⭐️ 부분은 모든 함수에서 공통적으로 볼 수 있다.</p>
  </li>
  <li>
    <p>이런 함수를 세 가지 방법으로 호출해보자.</p>
  </li>
</ul>

<h4 id="1-cdecl-declaration">1. cdecl (declaration)</h4>

<ul>
  <li>
    <p>함수 선언 부분을 <code class="language-plaintext highlighter-rouge">int __cdecl sum(int a, int b)</code> 로 변경해주면 된다.</p>
  </li>
  <li>
    <p>그럼 sum과 main 함수는 다음과 같이 만들어진다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;sum 함수&gt;
</span><span class="p">push ebp
mov ebp, esp
push ecx
mov eax, [ebp+arg_0]
add eax, [ebp+arg_4]
mov [ebp+var_4], eax
mov eax, [ebp+var_4]
mov esp, ebp
pop ebp
retn
</span>  
<span class="gd">&lt;main 함수&gt;
</span><span class="p">push 2
push 1
call calling.00401000
</span><span class="err">⭐️</span> add esp, 8
</code></pre></div>    </div>
  </li>
  <li>
    <p>⭐️ 부분은 스택을 사용한 만큼 다시 원래대로 당겨주는 의미</p>
  </li>
  <li>
    <p>즉 cdecl 은 함수를 호출한 쪽에서 스택을 보정해준다.</p>
  </li>
  <li>
    <p>add에 들어간 operand 값으로 파라미터의 데이터 사이즈를 알 수 있다.</p>
  </li>
  <li>
    <p>여기에서는 eax에 숫자가 들어가는 것으로 보아 리턴 값은 주소 값이 아닌 숫자임을 확인 할 수 있다.</p>
  </li>
</ul>

<h3 id="2-stdcall">2. stdcall</h3>

<ul>
  <li>
    <p>함수 선언 부분을 <code class="language-plaintext highlighter-rouge">int __stdcall sum(int a, int b)</code> 로 변경해주면 된다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;sum 함수&gt;
</span><span class="p">push ebp
mov ebp, esp
push ecx
mov eax, [ebp+arg_0]
add eax, [ebp+arg_4]
mov [ebp+var_4], eax
mov eax, [ebp+var_4]
mov esp, ebp
pop ebp
</span><span class="err">⭐️</span> retn 8
  
<span class="gd">&lt;main 함수&gt;
</span><span class="p">push 2
push 1
call calling.00401000
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>cdecl과 다르게  함수 안에서 스택을 보정한다.</p>
  </li>
  <li>
    <p>main의 <code class="language-plaintext highlighter-rouge">add esp, 8</code> 이 없어진 대신 retn에 8이 생겼다.</p>
  </li>
  <li>
    <p>Win32 API는 __stdcall 방식을 이용한다.</p>
  </li>
</ul>

<h3 id="3-fastcall">3. fastcall</h3>

<ul>
  <li>
    <p>함수 선언 부분을 <code class="language-plaintext highlighter-rouge">int __fastcall sum(int a, int b)</code> 로 변경해주면 된다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;sum 함수&gt;
</span><span class="p">push ebp
mov ebp, esp
</span><span class="err">⭐️</span> sub esp, 0Ch
<span class="p">mov [ebp+var_C], edx
mov [ebp+var_8], ecx
mov eax, [ebp+var_8]
add eax, [ebp+var_C]
mov [ebp+var_4], eax
mov eax, [ebp+var_4]
mov esp, ebp
pop ebp
retn
</span>  
<span class="gd">&lt;main 함수&gt;
</span><span class="p">push ebp
mov ebp, esp
</span><span class="err">⭐️</span> mov edx, 2
<span class="err">⭐️</span> mov ecx, 1
<span class="p">call sub_401000
xor eax, eax
pop ebp
retn
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>인자가 2개 이하일 때, stack에 값을 push하지 않고 ecx, edx 레지스터로 바로 계산하는 방식이다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sub esp, 0Ch</code> 로 스택 공간을 확보하고 edx 레지스터를 사용했다.</p>
  </li>
</ul>

  </section>
</div>

<div id="top" class="top-btn" onclick="moveTop()">
  <i class="fas fa-chevron-up"></i>
</div>

<script>
  var lastScrollTop = 0;
  window.onscroll = function () {
    var st = document.body.scrollTop || document.documentElement.scrollTop;
    if (st > 250) {
      document.getElementById("top").style.display = "block"
      if (st > lastScrollTop) {
        document.getElementById("top").style.opacity = 0
      } else {
        document.getElementById("top").style.opacity = 1
      }
    } else {
      document.getElementById("top").style.opacity = 0
      if (st > lastScrollTop) {
        document.getElementById("top").style.display = "none"
      }
    }
    lastScrollTop = st <= 0 ? 0 : st;
  }
  function moveTop() {
    document.body.scrollTop = 0
    document.documentElement.scrollTop = 0
  }
</script>

<!-- Footer -->
<footer>
  <div class="footer">
    Copyright © 2022
    <a href="https://cyc1am3n.github.io">Daeyoung Kim</a>.
  </div>
</footer>

  </div>
</body>

</html>