I"#g<p>해당 포스팅은 강병탁 교수님의 수업과 <a href="https://wikibook.co.kr/reverse-engineering-bible/">리버스 엔지니어링 바이블</a>을 참고해 작성했습니다.</p>

<hr />

<h3 id="if-문">if 문</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int Temp(int a) {
	int b = 1;
	if (a == 1) {
		a++;
	} else {
		b++;
	}
	return b;
}

int main(int argc, char* argv[]) {
	Temp(1);
}
</code></pre></div></div>

<ul>
  <li>
    <p>위의 코드를 디스어셈블링하면 다음과 같다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">.text:00401000</span> push ebp
<span class="err">.text:00401001</span> mov ebp, esp
<span class="err">.text:00401003</span> push ecx
<span class="err">.text:00401004</span> mov dword ptr [ebp-4],1
<span class="err">.text:0040100B</span> cmp dword ptr [ebp+8],1
<span class="err">.text:0040100F</span> jnz short loc_40101C
<span class="err">.text:00401011</span> mov eax, [ebp+8]
<span class="err">.text:00401014</span> add eax,1
<span class="err">.text:00401017</span> mov [ebp+8], eax
<span class="err">.text:0040101A</span> jmp short loc_401025
<span class="err">.text:0040101C</span> mov ecx, [ebp-4]
<span class="err">.text:0040101F</span> add ecx,1
<span class="err">.text:00401022</span> mov [ebp-4], ecx
<span class="err">.text:00401025</span> mov eax, [ebp-4]
<span class="err">.text:00401028</span> mov esp, ebp
<span class="err">.text:0040102A</span> pop ebp
<span class="err">.text:0040102B</span> retn
</code></pre></div>    </div>
  </li>
  <li>
    <p>함수의 골격은 다음과 같다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">.text:00401000</span> push ebp
<span class="err">.text:00401001</span> mov ebp, esp
<span class="err">...</span>
.text:00401028 mov esp, ebp
<span class="err">.text:0040102A</span> pop ebp
<span class="err">.text:0040102B</span> retn
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">push ecx</code> : ecx를 스택에 보관한다. 현재 지역 변수는 b 하나밖에 없어서 굳이 스택을 확보하지 않았다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">mov dword ptr [ebp-4]</code> : 스택에 값을 직접 넣는다. [ebp-4]는 b 변수에 해당하는 값이다. (int b=1)</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">cmp dword ptr [ebp+8], 1
jnz short loc_40101C
mov eax, [ebp+8]
add eax, 1
mov [ebp+8], eax
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>이 부분은 <code class="language-plaintext highlighter-rouge">if(a==1)</code> 에 해당한다.</p>
  </li>
  <li>
    <p>[ebp+8]은 첫 번째 파라미터(a)를 가리킨다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cmp dword ptr [ebp+8], 1</code> : 첫 번째 파라미터가 1인지 비교한다. 결과가 0이면(if(a==1)) jnz를 통과한다.</p>
  </li>
  <li>
    <p>마지막 세 줄은 [ebp+8], 즉 a에 1을 더하는 부분인데, 스택 메모리에서는 연산을 할 수 없기 때문에 <code class="language-plaintext highlighter-rouge">add [ebp+8], 1</code> 의 사용은 불가능하다.</p>
  </li>
  <li>
    <p>jnz에 걸렸을 경우도 현재 코드와 비슷하니 생략하겠다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">mov eax, [ebp-4]
mov esp, ebp
pop ebp
retn
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">mov eax, [ebp-4]</code> : eax에 b([ebp-4]) 변수의 값을 넣어주고 리턴한다. (리턴값은 eax이다.)</p>
  </li>
</ul>

<p><br /></p>

<h3 id="반복문">반복문</h3>

<ul>
  <li>
    <p>루프문은 for나 while, goto 등이 있지만 컴퓨터가 보기에는 결국 카운터 레지스터를 이용한 반복행위일 뿐이다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">loop</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="mh">0x100</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">--</span><span class="p">;</span>
    <span class="n">d</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>위의 코드를 디스어셈블링하면 다음과 같다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">.text:00401000</span> push ebp
<span class="err">.text:00401001</span> mov ebp, esp
<span class="err">.text:00401003</span> sub esp,8
<span class="err">.text:00401006</span> mov dword ptr [ebp-8],0
<span class="err">.text:0040100D</span> jmp short loc_401018
<span class="err">.text:0040100F</span> mov eax, [ebp-8]
<span class="err">.text:00401012</span> add eax,1
<span class="err">.text:00401015</span> mov [ebp-8], eax
<span class="err">.text:00401018</span> cmp dword ptr [ebp-8], 100h
<span class="err">.text:0040101F</span> jg short loc_401035
<span class="err">.text:00401021</span> mov ecx, [ebp+8]
<span class="err">.text:00401024</span> sub ecx,1
<span class="err">.text:00401027</span> mov [ebp+8], ecx
<span class="err">.text:0040102A</span> mov edx, [ebp-4]
<span class="err">.text:0040102D</span> add edx,1
<span class="err">.text:00401030</span> mov [ebp-4], edx
<span class="err">.text:00401033</span> jmp short loc_40100F
<span class="err">.text:00401035</span> mov eax, [ebp+8]
<span class="err">.text:00401038</span> add eax, [ebp-4]
<span class="err">.text:0040103B</span> mov esp, ebp
<span class="err">.text:0040103D</span> pop ebp
<span class="err">.text:0040103E</span> retn
</code></pre></div>    </div>
  </li>
  <li>
    <p>함수의 앞뒤 모습은 다음과 같다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">.text:00401000</span> push ebp
<span class="err">.text:00401001</span> mov ebp, esp
<span class="err">.text:00401003</span> sub esp,8 ⭐️
<span class="err">...</span>
.text:0040103B mov esp, ebp
<span class="err">.text:0040103D</span> pop ebp
<span class="err">.text:0040103E</span> retn
</code></pre></div>    </div>
  </li>
  <li>
    <p>⭐️ 부분은 함수 내에서 지역변수로 8바이트 사용하겠다는 의미이다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">.text:0040100F</span> mov eax, [ebp-8]
<span class="err">.text:00401012</span> add eax,1
<span class="err">.text:00401015</span> mov [ebp-8], eax
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 부분은 for문에서 i++에 해당한다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">.text:00401018</span> cmp dword ptr [ebp-8], 100h
<span class="err">.text:0040101F</span> jg short loc_401035
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">cmp dword ptr [ebp-8], 100h</code> : <a href="i">ebp-8</a>와 0x100과 비교한다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">jg short loc_401035</code> : [ebp-8]이 0x100과 비교해 크면 0x401035번지로 점프한다. (<code class="language-plaintext highlighter-rouge">jg</code> 는 jump greater를 의미)</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">.text:00401035</span> mov eax, [ebp+8]
<span class="err">.text:00401038</span> add eax, [ebp-4]
<span class="err">.text:0040103B</span> mov esp, ebp
<span class="err">.text:0040103D</span> pop ebp
<span class="err">.text:0040103E</span> retn
</code></pre></div>    </div>
  </li>
  <li>
    <p>i가 0x100보다 클 때 점프해서 도착한 부분이다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">mov eax, [ebp+8]</code> / <code class="language-plaintext highlighter-rouge">add eax, [ebp-4]</code> : return c + d에 해당하는 부분이다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">.text:00401021</span> mov ecx, [ebp+8]
<span class="err">.text:00401024</span> sub ecx,1
<span class="err">.text:00401027</span> mov [ebp+8], ecx
<span class="err">.text:0040102A</span> mov edx, [ebp-4]
<span class="err">.text:0040102D</span> add edx,1
<span class="err">.text:00401030</span> mov [ebp-4], edx
<span class="err">.text:00401033</span> jmp short loc_40100F
</code></pre></div>    </div>
  </li>
  <li>
    <p>jg를 통과해 for 문 안의 코드를 수행하는 부분이다.</p>
  </li>
  <li>
    <p>ecx를 활용해 <a href="d">ebp+8</a>에 1을 더하고, edx를 활용해 <a href="c">ebp-4</a>에 1을 더한다.</p>
  </li>
  <li>
    <p>그리고 다시 jg 부분으로 돌아가 대소비교를 진행한다.</p>
  </li>
</ul>

<p><br /></p>

<h3 id="구조체와-api-call">구조체와 API Call</h3>

<ul>
  <li>
    <p>구조체의 각 멤버 변수가 어떤 식으로 사용되는지 살펴볼 필요가 있다.</p>
  </li>
  <li>
    <p>또한 인자가 들어가는 상황에서는 디스어셈블된 코드가 어떻게 변경되는지 알아야 한다.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">STARTUPINFO</code> 와 <code class="language-plaintext highlighter-rouge">PROCESS_INFORMATION</code> 구조체를 이용해 <code class="language-plaintext highlighter-rouge">CreateProcess()</code> 로 새 프로세스를 생성하는 코드를 살펴보자.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">RunProcess</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">STARTUPINFO</span> <span class="n">si</span><span class="p">;</span>
  <span class="n">PROCESS_INFORMATION</span> <span class="n">pi</span><span class="p">;</span>
  <span class="n">ZeroMemory</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="p">);</span>
  <span class="n">si</span><span class="p">.</span><span class="n">cb</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">);</span>
  <span class="n">ZeroMemory</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="p">);</span>
  <span class="c1">// Start the child process.</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">CreateProcess</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="err">“</span><span class="n">MyChildProcess</span><span class="s">", NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi )) {</span><span class="err">
</span><span class="s">    printf( "</span><span class="n">CreateProcess</span> <span class="n">failed</span><span class="p">.</span><span class="err">\</span><span class="n">n</span><span class="s">" );</span><span class="err">
</span><span class="s">    return;</span><span class="err">
</span><span class="s">  }</span><span class="err">
</span><span class="s">  // Wait until child process exits.</span><span class="err">
</span><span class="s">  WaitForSingleObject( pi.hProcess, INFINITE );</span><span class="err">
</span><span class="s">  // Close process and thread handles.</span><span class="err">
</span><span class="s">  CloseHandle( pi.hProcess );</span><span class="err">
</span><span class="s">  CloseHandle( pi.hThread );</span><span class="err">
</span><span class="s">}</span><span class="err">
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">STARTUPINFO</code> 와 <code class="language-plaintext highlighter-rouge">PROCESS_INFORMATION</code> 구조체를 선언하고 <code class="language-plaintext highlighter-rouge">CreateProcess()</code> 를 호출한다.</p>
  </li>
  <li>
    <p>그러면 두 구조체에는 생성된 새 프로세스와 관련된 값이 들어오며, 해당 구조체의 멤버 변수인 프로세스 핸들을 이용해 프로세스가 종료될 때 까지 <code class="language-plaintext highlighter-rouge">WaitForSingleObject()</code> 로 대기한다.</p>
  </li>
  <li>
    <p>프로세스가 종료되면 관련 핸들을 닫는다.</p>
  </li>
  <li>
    <p>위 코드를 디스어셈블하면 다음과 같다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">0x401000 PUSH EBP
0x401001 MOV EBP,ESP
0x401003 SUB ESP,54
0x401006 PUSH 44
0x401008 PUSH 0
0x40100A LEA EAX,DWORD PTR SS:[EBP-54]
0x40100D PUSH EAX
0x40100E CALL calling.004011A0
0x401013 ADD ESP,0C
0x401016 MOV DWORD PTR SS:[EBP-54],44
0x40101D PUSH 10
0x40101F PUSH 0
0x401021 LEA ECX,DWORD PTR SS:[EBP-10]
0x401024 PUSH ECX
0x401025 CALL calling.004011A0
0x40102A ADD ESP,0C
0x40102D LEA EDX,DWORD PTR SS:[EBP-10]
0x401030 PUSH EDX
0x401031 LEA EAX,DWORD PTR SS:[EBP-54]
0x401034 PUSH EAX
0x401035 PUSH 0
0x401037 PUSH 0
0x401039 PUSH 0
0x40103B PUSH 0
0x40103D PUSH 0
0x40103F PUSH 0
0x401041 PUSH calling.00407030
0x401046 PUSH 0
0x401048 CALL DWORD PTR DS:CreateProcessA
0x40104E TEST EAX,EAX
0x401050 JNZ SHORT calling.00401061
0x401052 PUSH calling.00407040
0x401057 CALL calling.0040116F
0x40105C ADD ESP,4
0x40105F JMP SHORT calling.00401081
0x401061 PUSH -1
0x401063 MOV ECX,DWORD PTR SS:[EBP-10]
0x401066 PUSH ECX
0x401067 CALL DWORD PTR DS:WaitForSingleObject
0x40106D MOV EDX,DWORD PTR SS:[EBP-10]
0x401070 PUSH EDX
0x401071 CALL DWORD PTR DS:CloseHandle
0x401077 MOV EAX,DWORD PTR SS:[EBP-C]
0x40107A PUSH EAX
0x40107B CALL DWORD PTR DS:CloseHandle
0x401081 MOV ESP,EBP
0x401083 POP EBP
0x401084 RETN
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>코드가 길지만 처음부터 천천히 살펴보자.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;함수의 시작&gt;
</span><span class="p">0x401000 PUSH EBP
0x401001 MOV EBP,ESP
</span><span class="gd">&lt;스택 확보&gt;
</span><span class="p">0x401003 SUB ESP,54
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>레지스터만으로는 메모리를 감당할 수 없을 때 스택을 늘려서 공간을 확보하는데, 이 경우 0x54 바이트만큼 스택을 늘렸다.</p>
  </li>
  <li>
    <p>한편, 우리가 사용한 두 구조체는 다음과 같다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_STARTUPINFO</span> <span class="p">{</span>
  <span class="n">DWORD</span> <span class="n">cb</span><span class="p">;</span>            <span class="c1">// [EBP-54]</span>
  <span class="n">LPTSTR</span> <span class="n">lpReserved</span><span class="p">;</span>   <span class="c1">// [EBP-50]</span>
  <span class="n">LPTSTR</span> <span class="n">lpDesktop</span><span class="p">;</span>    <span class="c1">// [EBP-4C]</span>
  <span class="n">LPTSTR</span> <span class="n">lpTitle</span><span class="p">;</span>      <span class="c1">// ...</span>
  <span class="n">DWORD</span> <span class="n">dwX</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">dwY</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">dwXSize</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">dwYSize</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">dwXCountChars</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">dwYCountChars</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">dwFillAttribute</span><span class="p">;</span>
  <span class="n">DWORD</span> <span class="n">dwFlags</span><span class="p">;</span>
  <span class="n">WORD</span> <span class="n">wShowWindow</span><span class="p">;</span>
  <span class="n">WORD</span> <span class="n">cbReserved2</span><span class="p">;</span>
  <span class="n">LPBYTE</span> <span class="n">lpReserved2</span><span class="p">;</span>
  <span class="n">HANDLE</span> <span class="n">hStdInput</span><span class="p">;</span>
  <span class="n">HANDLE</span> <span class="n">hStdOutput</span><span class="p">;</span>
  <span class="n">HANDLE</span> <span class="n">hStdError</span><span class="p">;</span>
<span class="p">}</span> <span class="n">STARTUPINFO</span><span class="p">,</span> <span class="o">*</span><span class="n">LPSTARTUPINFO</span><span class="p">;</span>
  
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PROCESS_INFORMATION</span> <span class="p">{</span>
  <span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">;</span>     <span class="c1">// [EBP-10]</span>
  <span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">;</span>      <span class="c1">// [EBP-C]</span>
  <span class="n">DWORD</span> <span class="n">dwProcessId</span><span class="p">;</span>   <span class="c1">// [EBP-8] </span>
  <span class="n">DWORD</span> <span class="n">dwThreadId</span><span class="p">;</span>    <span class="c1">// [EBP-4]</span>
<span class="p">}</span> <span class="n">PROCESS_INFORMATION</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>멤버 변수의 데이터 타입 크기를 다 계산해보면 <code class="language-plaintext highlighter-rouge">PROCESS_INFORMATION</code> 은 0x10 바이트이고, <code class="language-plaintext highlighter-rouge">STARTUPINFO</code> 는 0x44 바이트이다.</p>

    <ul>
      <li>즉 함수에 매개변수로 넘겨준 구조체의 데이터 사이즈(0x54)만큼 스택을 확보한 것이다.</li>
    </ul>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;ZeroMemory(&amp;si, sizeof(si))&gt;
</span><span class="p">0x401006 PUSH 44
0x401008 PUSH 0
0x40100A LEA EAX,DWORD PTR SS:[EBP-54]
0x40100D PUSH EAX
0x40100E CALL calling.004011A0
0x401013 ADD ESP,0C
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">STARTUPINFO</code> 의 크기는 0x44 였고 0x40100A 에서는 그 구조체 [EBP-54]의 포인터를 eax에 넣고 <code class="language-plaintext highlighter-rouge">ZeroMemory()</code>에 전달한다. (CALL 부분)</p>
  </li>
  <li>
    <p>근데 CALL 윗 부분에서 PUSH로 전달한 변수는 총 3개인데, 원본 코드에서는 2개만 전달한다.</p>

    <ul>
      <li>
        <p>이는 <code class="language-plaintext highlighter-rouge">ZeroMemory()</code> 가 실제로는 <code class="language-plaintext highlighter-rouge">memset()</code> 으로 전처리된 구문이고, 바이너리로 <code class="language-plaintext highlighter-rouge">memset()</code> 인자 개수대로 변환되었던 것이다.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ZeroMemory 전처리문</span>
<span class="cp">#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))
#define ZeroMemory RtlZeroMemory
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>그 다음에는 <code class="language-plaintext highlighter-rouge">ADD ESP,0C</code> 로 PUSH 했던 스택을 원래대로 보정하는데, 함수를 호출한 후 보정하는 것으로 보아 <code class="language-plaintext highlighter-rouge">cdecl</code> 규약의 함수라는 것을 알 수 있다. (4바이트 3개를 사용했으므로 0x0C 만큼)</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;구조체의 첫 번째 멤버 변수 처리&gt;
</span><span class="p">0x401016 MOV DWORD PTR SS:[EBP-54],44
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>구조체의 첫 번째 멤버 변수에 0x44를 넣으라는 의미이다. (<code class="language-plaintext highlighter-rouge">si.cb=sizeof(si)</code>)</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;PROCESS_INFORMATION 초기화&gt;
</span><span class="p">0x40101D PUSH 10
0x40101F PUSH 0
0x401021 LEA ECX,DWORD PTR SS:[EBP-10]
0x401024 PUSH ECX
0x401025 CALL calling.004011A0
0x40102A ADD ESP,0C
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>첫 번째 구조체를 초기화 했던 방식과 동일하다. <code class="language-plaintext highlighter-rouge">PROCESS_INFORMATION</code> 구조체는 0x10 바이트이다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;CreateProcess&gt;
</span><span class="p">0x40102D LEA EDX,DWORD PTR SS:[EBP-10]
0x401030 PUSH EDX
0x401031 LEA EAX,DWORD PTR SS:[EBP-54]
0x401034 PUSH EAX
0x401035 PUSH 0
0x401037 PUSH 0
0x401039 PUSH 0
0x40103B PUSH 0
0x40103D PUSH 0
0x40103F PUSH 0
0x401041 PUSH calling.00407030
0x401046 PUSH 0
0x401048 CALL DWORD PTR DS:CreateProcessA
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">CreateProcess()</code> 를 호출하는 코드이다.</p>
  </li>
  <li>
    <p>CALL 문 이전에 호출되는 PUSH는 함수의 인자인데, 이는 원래 순서와 반대로 들어간다.</p>

    <ul>
      <li>스택은 LIFO의 특성을 가지고 있기 때문이다.</li>
    </ul>
  </li>
  <li>
    <p>0x40102D의 [EBP-10]은 <code class="language-plaintext highlighter-rouge">PROCESS_INFORMATION</code>의 주소(&amp;pi)이고,</p>
  </li>
  <li>
    <p>0x40102D의 [EBP-54]은 <code class="language-plaintext highlighter-rouge">STARTUPINFO</code> 의 주소(&amp;si)이다.</p>
  </li>
  <li>
    <p>또한 원본 코드에서 NULL, FALSE, 0 의 구분이 있었지만, 여기에서는 모두 0으로 적용된다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;NULL 리턴 시 에러 처리&gt;
</span><span class="p">0x40104E TEST EAX,EAX
0x401050 JNZ SHORT calling.00401061
0x401052 PUSH calling.00407040
0x401057 CALL calling.0040116F
0x40105C ADD ESP,4
0x40105F JMP SHORT calling.00401081
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>함수의 리턴값은 EAX에 들어오므로 <code class="language-plaintext highlighter-rouge">CreateProcess()</code> 가 NULL을 리턴했을 때에는 Zero flag가 1이 되어 점프문을 지나쳐 “CreateProcess failed.\n” 을 출력하는 코드이다.</p>
  </li>
  <li>
    <p>0x0040116F는 <code class="language-plaintext highlighter-rouge">printf()</code> 가 된다.</p>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;대기 후 클로즈 루틴&gt;
</span><span class="p">0x401061 PUSH -1
0x401063 MOV ECX,DWORD PTR SS:[EBP-10]
0x401066 PUSH ECX
0x401067 CALL DWORD PTR DS:WaitForSingleObject
0x40106D MOV EDX,DWORD PTR SS:[EBP-10]
0x401070 PUSH EDX
0x401071 CALL DWORD PTR DS:CloseHandle
0x401077 MOV EAX,DWORD PTR SS:[EBP-C]
0x40107A PUSH EAX
0x40107B CALL DWORD PTR DS:CloseHandle
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">WaitForSingleObject()</code> 에 두 개의 인자를 넣고 대기하는 코드이다.</p>
  </li>
  <li>
    <p>첫 번째 인자에는 핸들이 들어가야 하는데, [EBP-10] 은 <code class="language-plaintext highlighter-rouge">PROCESS_INFORMATION</code> 구조체이고,</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">DWORD PTR SS:</code> 로 4바이트를 넣으니 (DWORD는 4바이트를 의미) 첫 번째 인자인 <code class="language-plaintext highlighter-rouge">HANDLE hProcess</code>가 된다.</li>
    </ul>
  </li>
  <li>
    <p>두 번째 인자로는 -1을 전달하는데 이는 <code class="language-plaintext highlighter-rouge">INFINITE</code> 로 선언된 값이다.(WinBase.h 에서)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">WaitForSingleObject()</code> 가 리턴된 이후 각각의 인자로 <code class="language-plaintext highlighter-rouge">CloseHandle()</code> 을 실행하는데,</p>

    <ul>
      <li>[EBP-10] 은 방금 확인한 프로세스의 핸들이고,</li>
      <li>[EBP-C] 는 거기에서 4바이트 뒤인 <code class="language-plaintext highlighter-rouge">HANDLE hThread</code> 이다.</li>
    </ul>

    <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">&lt;함수 종료&gt;
</span><span class="p">0x401081 MOV ESP,EBP
0x401083 POP EBP
0x401084 RETN
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>마지막으로 스택을 원래대로 복구해놓고 함수를 종료한다.</p>
  </li>
</ul>
:ET